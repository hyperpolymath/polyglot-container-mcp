// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Deno from "../bindings/Deno.res.js";
import * as Adapter from "../Adapter.res.js";
import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Executor from "../Executor.res.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Stdlib_JSON from "@rescript/runtime/lib/es6/Stdlib_JSON.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

let dockerPath = $$Deno.getEnvOr("DOCKER_PATH", "docker");

let dockerHost = $$Deno.getEnvOr("DOCKER_HOST", "");

let allowedCommands = [
  "run",
  "create",
  "start",
  "stop",
  "restart",
  "kill",
  "rm",
  "pause",
  "unpause",
  "ps",
  "inspect",
  "logs",
  "top",
  "stats",
  "port",
  "diff",
  "exec",
  "attach",
  "cp",
  "export",
  "images",
  "pull",
  "push",
  "build",
  "tag",
  "rmi",
  "save",
  "load",
  "image",
  "history",
  "network",
  "volume",
  "compose",
  "info",
  "version",
  "system",
  "events",
  "login",
  "logout"
];

function sanitizeArg(arg) {
  return arg.replace(/[;&|`$(){}\\[\\]<>]/g, "").trim();
}

async function exec(subcommand, args) {
  if (!allowedCommands.includes(subcommand)) {
    Stdlib_Exn.raiseError(`Command not allowed: ` + subcommand);
  }
  let baseArgs = [];
  if (dockerHost !== "") {
    baseArgs.push("-H");
    baseArgs.push(dockerHost);
  }
  let fullArgs = baseArgs.concat([subcommand]).concat(args.map(sanitizeArg));
  return await Executor.executeCommand(dockerPath, fullArgs);
}

function parseJsonOutput(stdout) {
  try {
    let lines = stdout.trim().split("\n").filter(line => line !== "");
    if (lines.length === 0) {
      return [];
    } else if (lines.length === 1) {
      return JSON.parse(Stdlib_Option.getOr(lines[0], "[]"));
    } else {
      return lines.map(line => JSON.parse(line));
    }
  } catch (exn) {
    return {
      raw: stdout
    };
  }
}

async function connect() {
  let result = await exec("version", []);
  if (result.code !== 0) {
    return Stdlib_Exn.raiseError(`Docker not available: ` + result.stderr);
  }
}

async function disconnect() {
  
}

async function isConnected() {
  try {
    let result = await exec("version", []);
    return result.code === 0;
  } catch (exn) {
    return false;
  }
}

async function runHandler(args) {
  let image = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "image"), Stdlib_JSON.Decode.string), "");
  let containerName = Stdlib_Option.flatMap(Js_dict.get(args, "name"), Stdlib_JSON.Decode.string);
  let detach = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "detach"), Stdlib_JSON.Decode.bool), true);
  let ports = Stdlib_Option.flatMap(Js_dict.get(args, "ports"), Stdlib_JSON.Decode.string);
  let env = Stdlib_Option.flatMap(Js_dict.get(args, "env"), Stdlib_JSON.Decode.string);
  let volumes = Stdlib_Option.flatMap(Js_dict.get(args, "volumes"), Stdlib_JSON.Decode.string);
  let command = Stdlib_Option.flatMap(Js_dict.get(args, "command"), Stdlib_JSON.Decode.string);
  let privileged = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "privileged"), Stdlib_JSON.Decode.bool), false);
  let nested = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "nested"), Stdlib_JSON.Decode.bool), false);
  let cmdArgs = [];
  if (detach) {
    cmdArgs.push("-d");
  }
  Stdlib_Option.forEach(containerName, n => {
    cmdArgs.push("--name");
    cmdArgs.push(n);
  });
  if (privileged || nested) {
    cmdArgs.push("--privileged");
  }
  if (nested) {
    cmdArgs.push("-v");
    cmdArgs.push("/var/run/docker.sock:/var/run/docker.sock");
  }
  Stdlib_Option.forEach(ports, p => {
    p.split(",").forEach(port => {
      cmdArgs.push("-p");
      cmdArgs.push(port.trim());
    });
  });
  Stdlib_Option.forEach(env, e => {
    try {
      let envObj = JSON.parse(e);
      Js_dict.entries(envObj).forEach(param => {
        cmdArgs.push("-e");
        cmdArgs.push(param[0] + `=` + param[1]);
      });
      return;
    } catch (exn) {
      cmdArgs.push("-e");
      cmdArgs.push(e);
      return;
    }
  });
  Stdlib_Option.forEach(volumes, v => {
    v.split(",").forEach(vol => {
      cmdArgs.push("-v");
      cmdArgs.push(vol.trim());
    });
  });
  cmdArgs.push(image);
  Stdlib_Option.forEach(command, c => {
    c.split(" ").forEach(a => {
      cmdArgs.push(a);
    });
  });
  let result = await exec("run", cmdArgs);
  return {
    containerId: result.stdout.trim(),
    success: result.code === 0,
    nested: nested,
    privileged: privileged || nested,
    error: result.code !== 0 ? result.stderr : undefined
  };
}

async function psHandler(args) {
  let all = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "all"), Stdlib_JSON.Decode.bool), false);
  let cmdArgs = [
    "--format",
    "json"
  ];
  if (all) {
    cmdArgs.push("-a");
  }
  let result = await exec("ps", cmdArgs);
  return {
    containers: parseJsonOutput(result.stdout)
  };
}

async function stopHandler(args) {
  let containers = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "containers"), Stdlib_JSON.Decode.string), "");
  let result = await exec("stop", containers.split(",").map(prim => prim.trim()));
  return {
    stopped: containers.split(","),
    success: result.code === 0
  };
}

async function startHandler(args) {
  let containers = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "containers"), Stdlib_JSON.Decode.string), "");
  let result = await exec("start", containers.split(",").map(prim => prim.trim()));
  return {
    started: containers.split(","),
    success: result.code === 0
  };
}

async function restartHandler(args) {
  let containers = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "containers"), Stdlib_JSON.Decode.string), "");
  let result = await exec("restart", containers.split(",").map(prim => prim.trim()));
  return {
    restarted: containers.split(","),
    success: result.code === 0
  };
}

async function rmHandler(args) {
  let containers = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "containers"), Stdlib_JSON.Decode.string), "");
  let force = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "force"), Stdlib_JSON.Decode.bool), false);
  let cmdArgs = force ? ["-f"] : [];
  let result = await exec("rm", cmdArgs.concat(containers.split(",").map(prim => prim.trim())));
  return {
    removed: containers.split(","),
    success: result.code === 0
  };
}

async function logsHandler(args) {
  let container = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "container"), Stdlib_JSON.Decode.string), "");
  let tail = Stdlib_Option.map(Stdlib_Option.flatMap(Js_dict.get(args, "tail"), Stdlib_JSON.Decode.float), prim => prim | 0);
  let cmdArgs = tail !== undefined ? [
      "--tail",
      tail.toString(),
      container
    ] : [container];
  let result = await exec("logs", cmdArgs);
  return {
    logs: result.stdout,
    success: result.code === 0
  };
}

async function execHandler(args) {
  let container = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "container"), Stdlib_JSON.Decode.string), "");
  let command = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "command"), Stdlib_JSON.Decode.string), "");
  let result = await exec("exec", [container].concat(command.split(" ")));
  return {
    output: result.stdout,
    success: result.code === 0
  };
}

async function inspectHandler(args) {
  let target = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "target"), Stdlib_JSON.Decode.string), "");
  let result = await exec("inspect", [target]);
  return parseJsonOutput(result.stdout);
}

async function cpHandler(args) {
  let source = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "source"), Stdlib_JSON.Decode.string), "");
  let destination = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "destination"), Stdlib_JSON.Decode.string), "");
  let result = await exec("cp", [
    source,
    destination
  ]);
  return {
    success: result.code === 0
  };
}

async function imagesHandler(_args) {
  let result = await exec("images", [
    "--format",
    "json"
  ]);
  return {
    images: parseJsonOutput(result.stdout)
  };
}

async function pullHandler(args) {
  let image = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "image"), Stdlib_JSON.Decode.string), "");
  let result = await exec("pull", [image]);
  return {
    image: image,
    success: result.code === 0
  };
}

async function pushHandler(args) {
  let image = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "image"), Stdlib_JSON.Decode.string), "");
  let result = await exec("push", [image]);
  return {
    image: image,
    success: result.code === 0
  };
}

async function buildHandler(args) {
  let context = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "context"), Stdlib_JSON.Decode.string), ".");
  let tag = Stdlib_Option.flatMap(Js_dict.get(args, "tag"), Stdlib_JSON.Decode.string);
  let file = Stdlib_Option.flatMap(Js_dict.get(args, "file"), Stdlib_JSON.Decode.string);
  let cmdArgs = [];
  Stdlib_Option.forEach(tag, t => {
    cmdArgs.push("-t");
    cmdArgs.push(t);
  });
  Stdlib_Option.forEach(file, f => {
    cmdArgs.push("-f");
    cmdArgs.push(f);
  });
  cmdArgs.push(context);
  let result = await exec("build", cmdArgs);
  return {
    tag: tag,
    success: result.code === 0
  };
}

async function tagHandler(args) {
  let source = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "source"), Stdlib_JSON.Decode.string), "");
  let target = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "target"), Stdlib_JSON.Decode.string), "");
  let result = await exec("tag", [
    source,
    target
  ]);
  return {
    success: result.code === 0
  };
}

async function rmiHandler(args) {
  let images = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "images"), Stdlib_JSON.Decode.string), "");
  let result = await exec("rmi", images.split(",").map(prim => prim.trim()));
  return {
    removed: images.split(","),
    success: result.code === 0
  };
}

async function saveHandler(args) {
  let images = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "images"), Stdlib_JSON.Decode.string), "");
  let output = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "output"), Stdlib_JSON.Decode.string), "");
  let result = await exec("save", [
    "-o",
    output
  ].concat(images.split(",")));
  return {
    output: output,
    success: result.code === 0
  };
}

async function loadHandler(args) {
  let input = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "input"), Stdlib_JSON.Decode.string), "");
  let result = await exec("load", [
    "-i",
    input
  ]);
  return {
    success: result.code === 0
  };
}

async function networkLsHandler(_args) {
  let result = await exec("network", [
    "ls",
    "--format",
    "json"
  ]);
  return {
    networks: parseJsonOutput(result.stdout)
  };
}

async function networkCreateHandler(args) {
  let networkName = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "name"), Stdlib_JSON.Decode.string), "");
  let result = await exec("network", [
    "create",
    networkName
  ]);
  return {
    name: networkName,
    success: result.code === 0
  };
}

async function networkRmHandler(args) {
  let networks = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "networks"), Stdlib_JSON.Decode.string), "");
  let result = await exec("network", ["rm"].concat(networks.split(",")));
  return {
    removed: networks.split(","),
    success: result.code === 0
  };
}

async function networkInspectHandler(args) {
  let network = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "network"), Stdlib_JSON.Decode.string), "");
  let result = await exec("network", [
    "inspect",
    network
  ]);
  return parseJsonOutput(result.stdout);
}

async function volumeLsHandler(_args) {
  let result = await exec("volume", [
    "ls",
    "--format",
    "json"
  ]);
  return {
    volumes: parseJsonOutput(result.stdout)
  };
}

async function volumeCreateHandler(args) {
  let volumeName = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "name"), Stdlib_JSON.Decode.string), "");
  let result = await exec("volume", [
    "create",
    volumeName
  ]);
  return {
    name: volumeName,
    success: result.code === 0
  };
}

async function volumeRmHandler(args) {
  let volumes = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "volumes"), Stdlib_JSON.Decode.string), "");
  let result = await exec("volume", ["rm"].concat(volumes.split(",")));
  return {
    removed: volumes.split(","),
    success: result.code === 0
  };
}

async function volumeInspectHandler(args) {
  let volume = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "volume"), Stdlib_JSON.Decode.string), "");
  let result = await exec("volume", [
    "inspect",
    volume
  ]);
  return parseJsonOutput(result.stdout);
}

async function composeUpHandler(args) {
  let file = Stdlib_Option.flatMap(Js_dict.get(args, "file"), Stdlib_JSON.Decode.string);
  let detach = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "detach"), Stdlib_JSON.Decode.bool), true);
  let cmdArgs = file !== undefined ? [
      "-f",
      file,
      "up"
    ] : ["up"];
  if (detach) {
    cmdArgs.push("-d");
  }
  let result = await exec("compose", cmdArgs);
  return {
    success: result.code === 0
  };
}

async function composeDownHandler(args) {
  let file = Stdlib_Option.flatMap(Js_dict.get(args, "file"), Stdlib_JSON.Decode.string);
  let cmdArgs = file !== undefined ? [
      "-f",
      file,
      "down"
    ] : ["down"];
  let result = await exec("compose", cmdArgs);
  return {
    success: result.code === 0
  };
}

async function composePsHandler(args) {
  let file = Stdlib_Option.flatMap(Js_dict.get(args, "file"), Stdlib_JSON.Decode.string);
  let cmdArgs = file !== undefined ? [
      "-f",
      file,
      "ps",
      "--format",
      "json"
    ] : [
      "ps",
      "--format",
      "json"
    ];
  let result = await exec("compose", cmdArgs);
  return {
    services: parseJsonOutput(result.stdout)
  };
}

async function composeLogsHandler(args) {
  let file = Stdlib_Option.flatMap(Js_dict.get(args, "file"), Stdlib_JSON.Decode.string);
  let service = Stdlib_Option.flatMap(Js_dict.get(args, "service"), Stdlib_JSON.Decode.string);
  let cmdArgs = file !== undefined ? [
      "-f",
      file,
      "logs"
    ] : ["logs"];
  Stdlib_Option.forEach(service, s => {
    cmdArgs.push(s);
  });
  let result = await exec("compose", cmdArgs);
  return {
    logs: result.stdout
  };
}

async function infoHandler(_args) {
  let result = await exec("info", [
    "--format",
    "json"
  ]);
  return parseJsonOutput(result.stdout);
}

async function versionHandler(_args) {
  let result = await exec("version", [
    "--format",
    "json"
  ]);
  if (result.code === 0) {
    return parseJsonOutput(result.stdout);
  }
  let textResult = await exec("version", []);
  return {
    version: textResult.stdout
  };
}

async function statsHandler(args) {
  let containers = Stdlib_Option.flatMap(Js_dict.get(args, "containers"), Stdlib_JSON.Decode.string);
  let cmdArgs = [
    "--format",
    "json",
    "--no-stream"
  ];
  Stdlib_Option.forEach(containers, c => {
    c.split(",").forEach(cont => {
      cmdArgs.push(cont);
    });
  });
  let result = await exec("stats", cmdArgs);
  return {
    stats: parseJsonOutput(result.stdout)
  };
}

async function systemPruneHandler(args) {
  let all = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "all"), Stdlib_JSON.Decode.bool), false);
  let volumes = Stdlib_Option.getOr(Stdlib_Option.flatMap(Js_dict.get(args, "volumes"), Stdlib_JSON.Decode.bool), false);
  let cmdArgs = ["-f"];
  if (all) {
    cmdArgs.push("-a");
  }
  if (volumes) {
    cmdArgs.push("--volumes");
  }
  let result = await exec("system", ["prune"].concat(cmdArgs));
  return {
    success: result.code === 0
  };
}

let dict = {};

dict["docker_run"] = {
  description: "Run a container (consider nerdctl_run or podman_run instead)",
  params: Js_dict.fromArray([
    [
      "image",
      Adapter.stringParam("Image to run")
    ],
    [
      "name",
      Adapter.stringParam("Container name")
    ],
    [
      "detach",
      Adapter.boolParam("Run in background")
    ],
    [
      "ports",
      Adapter.stringParam("Port mappings")
    ],
    [
      "env",
      Adapter.stringParam("Environment variables (JSON)")
    ],
    [
      "volumes",
      Adapter.stringParam("Volume mounts")
    ],
    [
      "command",
      Adapter.stringParam("Command to run")
    ],
    [
      "privileged",
      Adapter.boolParam("Run in privileged mode")
    ],
    [
      "nested",
      Adapter.boolParam("Setup for Docker-in-Docker")
    ]
  ]),
  handler: runHandler
};

dict["docker_ps"] = {
  description: "List containers",
  params: Js_dict.fromArray([[
      "all",
      Adapter.boolParam("Show all")
    ]]),
  handler: psHandler
};

dict["docker_stop"] = {
  description: "Stop containers",
  params: Js_dict.fromArray([[
      "containers",
      Adapter.stringParam("Container(s)")
    ]]),
  handler: stopHandler
};

dict["docker_start"] = {
  description: "Start containers",
  params: Js_dict.fromArray([[
      "containers",
      Adapter.stringParam("Container(s)")
    ]]),
  handler: startHandler
};

dict["docker_restart"] = {
  description: "Restart containers",
  params: Js_dict.fromArray([[
      "containers",
      Adapter.stringParam("Container(s)")
    ]]),
  handler: restartHandler
};

dict["docker_rm"] = {
  description: "Remove containers",
  params: Js_dict.fromArray([
    [
      "containers",
      Adapter.stringParam("Container(s)")
    ],
    [
      "force",
      Adapter.boolParam("Force")
    ]
  ]),
  handler: rmHandler
};

dict["docker_logs"] = {
  description: "Fetch logs",
  params: Js_dict.fromArray([
    [
      "container",
      Adapter.stringParam("Container")
    ],
    [
      "tail",
      Adapter.numberParam("Lines")
    ]
  ]),
  handler: logsHandler
};

dict["docker_exec"] = {
  description: "Execute command",
  params: Js_dict.fromArray([
    [
      "container",
      Adapter.stringParam("Container")
    ],
    [
      "command",
      Adapter.stringParam("Command")
    ]
  ]),
  handler: execHandler
};

dict["docker_inspect"] = {
  description: "Inspect",
  params: Js_dict.fromArray([[
      "target",
      Adapter.stringParam("Target")
    ]]),
  handler: inspectHandler
};

dict["docker_cp"] = {
  description: "Copy files",
  params: Js_dict.fromArray([
    [
      "source",
      Adapter.stringParam("Source")
    ],
    [
      "destination",
      Adapter.stringParam("Destination")
    ]
  ]),
  handler: cpHandler
};

dict["docker_images"] = {
  description: "List images",
  params: {},
  handler: imagesHandler
};

dict["docker_pull"] = {
  description: "Pull image",
  params: Js_dict.fromArray([[
      "image",
      Adapter.stringParam("Image")
    ]]),
  handler: pullHandler
};

dict["docker_push"] = {
  description: "Push image",
  params: Js_dict.fromArray([[
      "image",
      Adapter.stringParam("Image")
    ]]),
  handler: pushHandler
};

dict["docker_build"] = {
  description: "Build image",
  params: Js_dict.fromArray([
    [
      "context",
      Adapter.stringParam("Context")
    ],
    [
      "tag",
      Adapter.stringParam("Tag")
    ],
    [
      "file",
      Adapter.stringParam("File")
    ]
  ]),
  handler: buildHandler
};

dict["docker_tag"] = {
  description: "Tag image",
  params: Js_dict.fromArray([
    [
      "source",
      Adapter.stringParam("Source")
    ],
    [
      "target",
      Adapter.stringParam("Target")
    ]
  ]),
  handler: tagHandler
};

dict["docker_rmi"] = {
  description: "Remove images",
  params: Js_dict.fromArray([[
      "images",
      Adapter.stringParam("Image(s)")
    ]]),
  handler: rmiHandler
};

dict["docker_save"] = {
  description: "Save image",
  params: Js_dict.fromArray([
    [
      "images",
      Adapter.stringParam("Image(s)")
    ],
    [
      "output",
      Adapter.stringParam("Output")
    ]
  ]),
  handler: saveHandler
};

dict["docker_load"] = {
  description: "Load image",
  params: Js_dict.fromArray([[
      "input",
      Adapter.stringParam("Input")
    ]]),
  handler: loadHandler
};

dict["docker_network_ls"] = {
  description: "List networks",
  params: {},
  handler: networkLsHandler
};

dict["docker_network_create"] = {
  description: "Create network",
  params: Js_dict.fromArray([[
      "name",
      Adapter.stringParam("Name")
    ]]),
  handler: networkCreateHandler
};

dict["docker_network_rm"] = {
  description: "Remove networks",
  params: Js_dict.fromArray([[
      "networks",
      Adapter.stringParam("Network(s)")
    ]]),
  handler: networkRmHandler
};

dict["docker_network_inspect"] = {
  description: "Inspect network",
  params: Js_dict.fromArray([[
      "network",
      Adapter.stringParam("Network")
    ]]),
  handler: networkInspectHandler
};

dict["docker_volume_ls"] = {
  description: "List volumes",
  params: {},
  handler: volumeLsHandler
};

dict["docker_volume_create"] = {
  description: "Create volume",
  params: Js_dict.fromArray([[
      "name",
      Adapter.stringParam("Name")
    ]]),
  handler: volumeCreateHandler
};

dict["docker_volume_rm"] = {
  description: "Remove volumes",
  params: Js_dict.fromArray([[
      "volumes",
      Adapter.stringParam("Volume(s)")
    ]]),
  handler: volumeRmHandler
};

dict["docker_volume_inspect"] = {
  description: "Inspect volume",
  params: Js_dict.fromArray([[
      "volume",
      Adapter.stringParam("Volume")
    ]]),
  handler: volumeInspectHandler
};

dict["docker_compose_up"] = {
  description: "Start compose",
  params: Js_dict.fromArray([
    [
      "file",
      Adapter.stringParam("File")
    ],
    [
      "detach",
      Adapter.boolParam("Detach")
    ]
  ]),
  handler: composeUpHandler
};

dict["docker_compose_down"] = {
  description: "Stop compose",
  params: Js_dict.fromArray([[
      "file",
      Adapter.stringParam("File")
    ]]),
  handler: composeDownHandler
};

dict["docker_compose_ps"] = {
  description: "List compose services",
  params: Js_dict.fromArray([[
      "file",
      Adapter.stringParam("File")
    ]]),
  handler: composePsHandler
};

dict["docker_compose_logs"] = {
  description: "Compose logs",
  params: Js_dict.fromArray([
    [
      "file",
      Adapter.stringParam("File")
    ],
    [
      "service",
      Adapter.stringParam("Service")
    ]
  ]),
  handler: composeLogsHandler
};

dict["docker_info"] = {
  description: "System info",
  params: {},
  handler: infoHandler
};

dict["docker_version"] = {
  description: "Version",
  params: {},
  handler: versionHandler
};

dict["docker_stats"] = {
  description: "Stats",
  params: Js_dict.fromArray([[
      "containers",
      Adapter.stringParam("Container(s)")
    ]]),
  handler: statsHandler
};

dict["docker_system_prune"] = {
  description: "Prune",
  params: Js_dict.fromArray([
    [
      "all",
      Adapter.boolParam("All")
    ],
    [
      "volumes",
      Adapter.boolParam("Volumes")
    ]
  ]),
  handler: systemPruneHandler
};

let name = "docker";

let description = "Docker CLI - Fallback (prefer nerdctl or podman)";

let tools = dict;

export {
  dockerPath,
  dockerHost,
  allowedCommands,
  sanitizeArg,
  exec,
  parseJsonOutput,
  name,
  description,
  connect,
  disconnect,
  isConnected,
  runHandler,
  psHandler,
  stopHandler,
  startHandler,
  restartHandler,
  rmHandler,
  logsHandler,
  execHandler,
  inspectHandler,
  cpHandler,
  imagesHandler,
  pullHandler,
  pushHandler,
  buildHandler,
  tagHandler,
  rmiHandler,
  saveHandler,
  loadHandler,
  networkLsHandler,
  networkCreateHandler,
  networkRmHandler,
  networkInspectHandler,
  volumeLsHandler,
  volumeCreateHandler,
  volumeRmHandler,
  volumeInspectHandler,
  composeUpHandler,
  composeDownHandler,
  composePsHandler,
  composeLogsHandler,
  infoHandler,
  versionHandler,
  statsHandler,
  systemPruneHandler,
  tools,
}
/* dockerPath Not a pure module */
