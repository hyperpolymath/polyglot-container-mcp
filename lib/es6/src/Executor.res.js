// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";
import * as DenoResJs from "./bindings/Deno.res.js";

let allowedCommands = [
  "run",
  "create",
  "start",
  "stop",
  "restart",
  "kill",
  "rm",
  "pause",
  "unpause",
  "ps",
  "inspect",
  "logs",
  "top",
  "stats",
  "port",
  "diff",
  "exec",
  "attach",
  "cp",
  "export",
  "images",
  "pull",
  "push",
  "build",
  "tag",
  "rmi",
  "save",
  "load",
  "image",
  "history",
  "network",
  "volume",
  "compose",
  "info",
  "version",
  "system",
  "events",
  "login",
  "logout"
];

function getBinary(runtime) {
  switch (runtime) {
    case "Nerdctl" :
      return "nerdctl";
    case "Podman" :
      return "podman";
    case "Docker" :
      return "docker";
  }
}

function sanitizeArg(arg) {
  return arg.replace(/[;&|`$(){}\\[\\]<>]/g, "").trim();
}

function validateCommand(subcommand) {
  return allowedCommands.includes(subcommand);
}

function checkBinaryExists(prim) {
  return DenoResJs.checkBinaryExists(prim);
}

function executeCommand(prim0, prim1) {
  return DenoResJs.executeCommand(prim0, prim1);
}

async function exec(runtime, subcommand, args) {
  if (!allowedCommands.includes(subcommand)) {
    return {
      TAG: "Error",
      _0: {
        TAG: "CommandNotAllowed",
        _0: subcommand
      }
    };
  }
  let binary = getBinary(runtime);
  let sanitizedArgs = args.map(sanitizeArg);
  let fullArgs = [subcommand].concat(sanitizedArgs);
  try {
    let result = await DenoResJs.executeCommand(binary, fullArgs);
    return {
      TAG: "Ok",
      _0: result
    };
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      let message = Belt_Option.getWithDefault(e._1.message, "Unknown error");
      return {
        TAG: "Error",
        _0: {
          TAG: "ExecutionFailed",
          _0: message
        }
      };
    }
    throw e;
  }
}

async function execJson(runtime, subcommand, args) {
  let jsonArgs;
  let exit = 0;
  switch (subcommand) {
    case "images" :
    case "info" :
    case "inspect" :
    case "network" :
    case "ps" :
    case "version" :
    case "volume" :
      exit = 1;
      break;
    default:
      jsonArgs = args;
  }
  if (exit === 1) {
    jsonArgs = args.concat([
      "--format",
      "json"
    ]);
  }
  return await exec(runtime, subcommand, jsonArgs);
}

async function detectRuntimes() {
  let available = [];
  if (await DenoResJs.checkBinaryExists("nerdctl")) {
    available.push("Nerdctl");
  }
  if (await DenoResJs.checkBinaryExists("podman")) {
    available.push("Podman");
  }
  if (await DenoResJs.checkBinaryExists("docker")) {
    available.push("Docker");
  }
  return available;
}

async function getPreferredRuntime() {
  let available = await detectRuntimes();
  if (available.includes("Nerdctl")) {
    return "Nerdctl";
  } else if (available.includes("Podman")) {
    return "Podman";
  } else if (available.includes("Docker")) {
    return "Docker";
  } else {
    return;
  }
}

export {
  allowedCommands,
  getBinary,
  sanitizeArg,
  validateCommand,
  checkBinaryExists,
  executeCommand,
  exec,
  execJson,
  detectRuntimes,
  getPreferredRuntime,
}
/* ./bindings/Deno.res.js Not a pure module */
